/*
	结构型模式：代理模式
	1.模式动机：
		在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为"代理"的第三者来实现间接引用。
		代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不能看到的内容和服务或者添加客户需要的额外服务。
		通过引入一个新的对象来实现对真实对象的操作或者将新的对象作为真实对象的一个替身，
		这种实现机制即为代理模式，通过引入代理对象来间接访问一个对象，这就是代理模式的模式动机。
	2.模式定义：
		由于某些原因需要给某对象提供一个代理以控制对该对象的访问。
		这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。
	3.优点：
		代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；
		代理对象可以扩展目标对象的功能；
		代理模式能将调用者与目标对象分离，在一定程度上降低了系统的耦合度；
	4.缺点：
		在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；
		增加了系统的复杂度；
	5.适用场景：
		（1）远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。
		例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。
		（2）虚拟代理，如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。
		（3）安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。
		（4）智能引用，当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。
*/

package main

import "fmt"

func main() {
	w := CreateWeiXin(&Station{})
	w.BuyTicket()
}

/*
	购买车票无需到车站购买，可以在微信小程序购买，微信小程序扮演代理角色。
*/

// 抽象主题：购票
type Ticket interface {
	BuyTicket()
}

// 真实主题：车站
type Station struct {
}

func (s *Station) BuyTicket() {
	fmt.Println("购票成功")
}

// 代理：微信小程序
type WeiXin struct {
	station *Station
}

func (w *WeiXin) BuyTicket() {
	w.station.BuyTicket()
}

func CreateWeiXin(s *Station) *WeiXin {
	return &WeiXin{s}
}
